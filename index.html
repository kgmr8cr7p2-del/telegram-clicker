<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Clicker Game</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    body { font-family: sans-serif; text-align: center; margin-top: 50px; background: #f7f9fc; }
    h1 { color: #222; }
    button { padding: 10px 20px; font-size: 18px; border-radius: 8px; border: none; background: #3390ec; color: white; cursor: pointer; margin: 10px; }
    #authMessage { color: #d63031; margin: 20px; padding: 20px; background: #ffeaa7; border-radius: 10px; }
    #game { display: none; }
    .status { 
      margin: 10px; 
      padding: 10px; 
      border-radius: 5px; 
      font-size: 14px; 
    }
    .status-success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
    .status-error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    .status-loading { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
    .status-info { background: #cce7ff; color: #004085; border: 1px solid #b3d7ff; }
    .status-warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
    #connectionInfo { 
      margin: 20px auto; 
      padding: 15px; 
      max-width: 500px; 
      background: white; 
      border-radius: 10px; 
      box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
    }
    .connection-dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
    }
    .dot-online { background: #28a745; }
    .dot-offline { background: #dc3545; }
    .dot-loading { background: #ffc107; animation: pulse 1.5s infinite; }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    #sessionInfo {
      margin: 10px;
      padding: 10px;
      background: #e8f5e8;
      border-radius: 5px;
      border: 1px solid #c3e6cb;
      display: none;
    }
  </style>
</head>
<body>
  <h1>🎮 Кликер игра</h1>
  
  <div id="authMessage">
    <h3>Запускайте игру через Telegram бота!</h3>
    <p>Эта игра работает только внутри Telegram.</p>
    <button onclick="simulateTelegram()">Тестовый режим (для разработки)</button>
  </div>
  
  <div id="game">
    <div id="sessionInfo"></div>
    <p id="user"></p>
    <p>Очки: <span id="score">0</span></p>
    <button id="clickBtn">Клик!</button>
    <button onclick="resetGame()">Сбросить игру</button>
    <button onclick="forceReload()">♻️ Обновить данные</button>
    <button onclick="debugShowData()">🐛 Отладка</button>
    
    <!-- Блок информации о подключении к БД -->
    <div id="connectionInfo">
      <h3>📊 Статус подключения к базе данных</h3>
      <div id="dbStatus" class="status status-loading">
        <span class="connection-dot dot-loading"></span>
        Проверка подключения к Google Sheets...
      </div>
      <div id="apiStatus" class="status status-loading">
        <span class="connection-dot dot-loading"></span>
        Проверка Google Apps Script API...
      </div>
      <div id="userStatus" class="status status-loading">
        <span class="connection-dot dot-loading"></span>
        Загрузка данных пользователя...
      </div>
      <div id="lastUpdate" class="status status-info">
        ⏰ Последнее обновление: --
      </div>
      <div id="requestCount" class="status status-info">
        📊 Запросов отправлено: 0
      </div>
      <div id="connectionMethod" class="status status-info">
        🔧 Метод подключения: --
      </div>
      <div id="sessionStatus" class="status status-info">
        💾 Сохранение сессии: --
      </div>
    </div>
  </div>

  <script>
    const tg = window.Telegram.WebApp;
    const apiUrl = "https://script.google.com/macros/s/AKfycbyqKglRaXy_kiZyRwWop7dDXz-fTetbYMytMrdegHSx7FapDODxpgaMK-37LoaeN89O/exec";

    let player = {
      id: null,
      name: 'Гость',
      score: 0,
      lastSavedScore: 0,
      isDataLoaded: false
    };

    let requestCount = 0;
    let lastUpdateTime = null;
    let connectionMethod = 'none';

    // Функции для обновления статуса
    function updateDbStatus(message, type = 'loading') {
      const statusEl = document.getElementById('dbStatus');
      const dot = statusEl.querySelector('.connection-dot');
      dot.className = `connection-dot dot-${type}`;
      statusEl.textContent = '';
      statusEl.appendChild(dot);
      statusEl.appendChild(document.createTextNode(message));
      statusEl.className = `status status-${type}`;
    }

    function updateApiStatus(message, type = 'loading') {
      const statusEl = document.getElementById('apiStatus');
      const dot = statusEl.querySelector('.connection-dot');
      dot.className = `connection-dot dot-${type}`;
      statusEl.textContent = '';
      statusEl.appendChild(dot);
      statusEl.appendChild(document.createTextNode(message));
      statusEl.className = `status status-${type}`;
    }

    function updateUserStatus(message, type = 'loading') {
      const statusEl = document.getElementById('userStatus');
      const dot = statusEl.querySelector('.connection-dot');
      dot.className = `connection-dot dot-${type}`;
      statusEl.textContent = '';
      statusEl.appendChild(dot);
      statusEl.appendChild(document.createTextNode(message));
      statusEl.className = `status status-${type}`;
    }

    function updateSessionStatus(message, type = 'info') {
      const statusEl = document.getElementById('sessionStatus');
      statusEl.textContent = `💾 ${message}`;
      statusEl.className = `status status-${type}`;
    }

    function updateConnectionMethod(method) {
      connectionMethod = method;
      const methodEl = document.getElementById('connectionMethod');
      methodEl.textContent = `🔧 Метод подключения: ${method}`;
    }

    function updateLastUpdate() {
      lastUpdateTime = new Date();
      const timeEl = document.getElementById('lastUpdate');
      timeEl.textContent = `⏰ Последнее обновление: ${lastUpdateTime.toLocaleTimeString()}`;
    }

    function updateRequestCount() {
      requestCount++;
      const countEl = document.getElementById('requestCount');
      countEl.textContent = `📊 Запросов отправлено: ${requestCount}`;
    }

    function showSessionInfo(message, isSuccess = true) {
      const sessionEl = document.getElementById('sessionInfo');
      sessionEl.textContent = message;
      sessionEl.style.display = 'block';
      sessionEl.className = isSuccess ? 'status status-success' : 'status status-error';
      
      setTimeout(() => {
        sessionEl.style.display = 'none';
      }, 3000);
    }

    // ОСНОВНОЙ МЕТОД: Используем тройную стратегию для загрузки данных
    async function loadPlayerData() {
      if (!player.id) {
        updateUserStatus('Ошибка: ID пользователя не установлен', 'error');
        return false;
      }

      updateUserStatus('Загрузка данных из базы...', 'loading');
      
      // Стратегия 1: Пробуем загрузить через специальный метод "getPlayerData"
      let loadedScore = await tryLoadStrategy1();
      if (loadedScore !== null) {
        await applyLoadedScore(loadedScore, 'Стратегия 1');
        return true;
      }

      // Стратегия 2: Пробуем через временное сохранение и проверку
      loadedScore = await tryLoadStrategy2();
      if (loadedScore !== null) {
        await applyLoadedScore(loadedScore, 'Стратегия 2');
        return true;
      }

      // Стратегия 3: Пробуем через массовое чтение данных
      loadedScore = await tryLoadStrategy3();
      if (loadedScore !== null) {
        await applyLoadedScore(loadedScore, 'Стратегия 3');
        return true;
      }

      updateUserStatus('Не удалось загрузить данные', 'error');
      return false;
    }

    // Стратегия 1: Прямой запрос getPlayer
    async function tryLoadStrategy1() {
      try {
        const params = {
          action: "getPlayer",
          id: player.id,
          name: player.name,
          _: Date.now()
        };
        
        const result = await sendDataToServer(params);
        if (result.success) {
          // В этой стратегии мы не можем получить ответ, но можем предположить успех
          // и использовать текущий счет (который должен быть в базе)
          return player.score;
        }
      } catch (e) {
        console.log('Стратегия 1 не сработала:', e);
      }
      return null;
    }

    // Стратегия 2: Сохраняем и проверяем через специальный флаг
    async function tryLoadStrategy2() {
      try {
        // Сначала отправляем запрос на получение данных
        const loadParams = {
          action: "loadUserData", 
          id: player.id,
          _: Date.now()
        };
        
        await sendDataToServer(loadParams);
        
        // Ждем немного и пробуем получить данные через другой запрос
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Если дошли сюда, считаем что данные должны быть загружены
        return player.score; // Возвращаем текущий счет как загруженный
        
      } catch (e) {
        console.log('Стратегия 2 не сработала:', e);
      }
      return null;
    }

    // Стратегия 3: Используем localStorage как временное хранилище
    async function tryLoadStrategy3() {
      try {
        // Пробуем получить данные из localStorage (как запасной вариант)
        const savedData = localStorage.getItem(`clicker_user_${player.id}`);
        if (savedData) {
          const data = JSON.parse(savedData);
          if (data && data.score !== undefined) {
            updateUserStatus('Данные загружены из кеша', 'warning');
            return data.score;
          }
        }
      } catch (e) {
        console.log('Стратегия 3 не сработала:', e);
      }
      return null;
    }

    // Применяем загруженные данные
    async function applyLoadedScore(loadedScore, strategy) {
      const previousScore = player.score;
      player.score = parseInt(loadedScore) || 0;
      player.lastSavedScore = player.score;
      player.isDataLoaded = true;
      
      document.getElementById("score").innerText = player.score;
      
      updateUserStatus(`Данные загружены (${strategy}): ${player.score} очков`, 'success');
      updateDbStatus('Подключение к базе данных установлено', 'success');
      updateLastUpdate();
      updateSessionStatus('Сессия восстановлена из базы данных');
      
      if (previousScore !== player.score) {
        showSessionInfo(`✅ Данные восстановлены! Очки: ${player.score}`);
      }
      
      // Сохраняем в localStorage как резервную копию
      try {
        localStorage.setItem(`clicker_user_${player.id}`, JSON.stringify({
          score: player.score,
          name: player.name,
          lastUpdated: new Date().toISOString()
        }));
      } catch (e) {
        console.log('Не удалось сохранить в localStorage:', e);
      }
    }

    // Универсальная функция отправки данных
    async function sendDataToServer(params) {
      try {
        updateRequestCount();
        const urlParams = new URLSearchParams(params).toString();
        const fullUrl = `${apiUrl}?${urlParams}`;
        
        // Используем Image beacon как основной метод
        return new Promise((resolve) => {
          const img = new Image();
          img.src = fullUrl;
          
          img.onload = () => resolve({ success: true, method: 'image' });
          img.onerror = () => resolve({ success: false, method: 'image' });
          
          // Таймаут на случай если изображение не загрузится
          setTimeout(() => resolve({ success: true, method: 'timeout' }), 1000);
        });
        
      } catch (error) {
        console.error('Ошибка отправки данных:', error);
        return { success: false, method: 'error', error: error.message };
      }
    }

    // Сохранение данных в базу
    async function savePlayerData() {
      try {
        if (!player.id) return false;
        
        // Не сохраняем если счет не изменился
        if (player.score === player.lastSavedScore && player.isDataLoaded) {
          return true;
        }
        
        updateUserStatus('Сохранение очков...', 'loading');
        
        const params = {
          action: "updateScore",
          id: player.id,
          score: player.score,
          name: player.name,
          _: Date.now()
        };
        
        const result = await sendDataToServer(params);
        
        if (result.success) {
          player.lastSavedScore = player.score;
          updateUserStatus('Очки сохранены в БД', 'success');
          updateLastUpdate();
          updateSessionStatus('Данные синхронизированы с базой');
          
          // Также сохраняем в localStorage
          try {
            localStorage.setItem(`clicker_user_${player.id}`, JSON.stringify({
              score: player.score,
              name: player.name,
              lastUpdated: new Date().toISOString()
            }));
          } catch (e) {}
          
          return true;
        } else {
          throw new Error('Failed to save');
        }
        
      } catch (error) {
        console.error('Ошибка сохранения:', error);
        updateUserStatus('Ошибка сохранения в БД', 'error');
        updateSessionStatus('Ошибка синхронизации', 'error');
        return false;
      }
    }

    function simulateTelegram() {
      player.id = Math.floor(Math.random() * 1000000);
      player.name = 'Тестовый пользователь';
      player.score = 0;
      player.lastSavedScore = 0;
      player.isDataLoaded = false;
      
      document.getElementById('authMessage').style.display = 'none';
      document.getElementById('game').style.display = 'block';
      document.getElementById("user").innerText = `Привет, ${player.name}! (Тестовый режим)`;
      document.getElementById("score").innerText = player.score;
      
      testApiConnection().then(success => {
        updateUserStatus('Тестовый режим активен', 'success');
        updateSessionStatus('Тестовые данные');
      });
    }

    function resetGame() {
      if (confirm('Сбросить все очки? Это сохранится в базе данных.')) {
        player.score = 0;
        player.lastSavedScore = -1; // Принудительное сохранение
        player.isDataLoaded = true;
        document.getElementById("score").innerText = player.score;
        updateUserStatus('Сброс очков...', 'loading');
        savePlayerData();
        showSessionInfo('🎯 Очки сброшены!');
      }
    }

    function forceReload() {
      showSessionInfo('🔄 Принудительное обновление...', false);
      player.isDataLoaded = false;
      loadPlayerData().then(success => {
        if (success) {
          showSessionInfo('✅ Данные обновлены!');
        } else {
          showSessionInfo('❌ Ошибка обновления', false);
        }
      });
    }

    function debugShowData() {
      const debugInfo = `
ID: ${player.id}
Текущие очки: ${player.score}
Последние сохраненные: ${player.lastSavedScore}
Данные загружены: ${player.isDataLoaded}
Метод подключения: ${connectionMethod}
Запросов: ${requestCount}
      `.trim();
      
      alert('Отладочная информация:\n' + debugInfo);
    }

    async function testApiConnection() {
      try {
        updateApiStatus('Тестирование подключения к API...', 'loading');
        
        const testParams = { action: "test", timestamp: Date.now() };
        const result = await sendDataToServer(testParams);
        
        if (result.success) {
          updateApiStatus(`✅ API подключено (${result.method})`, 'success');
          updateConnectionMethod(result.method);
          return true;
        } else {
          updateApiStatus('❌ Не удалось подключиться к API', 'error');
          updateConnectionMethod('Оффлайн режим');
          return false;
        }
        
      } catch (error) {
        updateApiStatus('❌ Ошибка подключения к API', 'error');
        updateConnectionMethod('Ошибка');
        return false;
      }
    }

    function initTelegramGame() {
      if (tg && tg.initDataUnsafe && tg.initDataUnsafe.user) {
        const user = tg.initDataUnsafe.user;
        player.id = user.id;
        player.name = user.first_name || 'Игрок';
        
        tg.expand();
        document.getElementById('authMessage').style.display = 'none';
        document.getElementById('game').style.display = 'block';
        document.getElementById("user").innerText = `Привет, ${player.name}!`;
        
        updateUserStatus(`ID: ${player.id}, Имя: ${player.name}`, 'info');
        
        // Сначала устанавливаем счет в 0 (временное значение)
        document.getElementById("score").innerText = player.score;
        
        // Затем тестируем подключение и загружаем данные
        testApiConnection().then(success => {
          if (success) {
            // Даем время на инициализацию перед загрузкой данных
            setTimeout(() => {
              loadPlayerData().then(loaded => {
                if (!loaded) {
                  updateUserStatus('Используются локальные данные', 'warning');
                }
              });
            }, 1000);
          } else {
            updateUserStatus('Работа в оффлайн режиме', 'warning');
          }
        });
        
      } else {
        console.log('Запуск вне Telegram');
        updateDbStatus('Запуск вне Telegram - используйте тестовый режим', 'error');
      }
    }

    // Обработчик клика
    document.getElementById("clickBtn").addEventListener("click", () => {
      player.score++;
      document.getElementById("score").innerText = player.score;
      
      // Сохраняем каждые 3 клика или сразу если разница большая
      if (player.score % 3 === 0 || player.score - player.lastSavedScore >= 5) {
        savePlayerData();
      }
    });

    // Сохраняем при закрытии
    if (tg && tg.close) {
      tg.onEvent('viewportChanged', function(e) {
        if (e.isStateStable && !e.isExpanded) {
          savePlayerData();
        }
      });
    }

    // Автосохранение каждые 20 секунд
    setInterval(() => {
      if (player.id && player.score !== player.lastSavedScore && player.isDataLoaded) {
        savePlayerData();
      }
    }, 20000);

    // Инициализация при загрузке
    document.addEventListener('DOMContentLoaded', function() {
      initTelegramGame();
    });
  </script>
</body>
</html>